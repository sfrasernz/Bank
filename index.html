<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Banking Cash Counter (Grid + 85-note bundles)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111a24;
      --panel2:#0f1620;
      --text:#eaf2ff;
      --muted:#a6b3c5;
      --line:#223244;
      --good:#1f8f4a;
      --warn:#b88b00;
      --bad:#b02a2a;
      --shadow: 0 10px 24px rgba(0,0,0,.35);
      --radius: 14px;
      --cell:#0b131c;
      --focus:#3aa0ff;

      --base-font: 16px;
      --cell-font: 18px;
      --cell-pad-y: 10px;
      --cell-pad-x: 12px;
      --th-font: 15px;
      --td-pad: 10px;
      --bundle-width: 640px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(180deg, #070a0f 0%, var(--bg) 100%);
      color:var(--text);
      font-size: var(--base-font);
    }

    header{
      position: sticky; top:0;
      background: rgba(11,15,20,.92);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--line);
      padding: 12px 16px;
      z-index: 5;
    }
    .hdrRow{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pill{
      background: rgba(26,38,52,.9);
      border:1px solid var(--line);
      border-radius: 999px;
      padding: 10px 14px;
      display:flex;
      gap:10px;
      align-items:center;
      font-size: 15px;
      white-space: nowrap;
    }
    .pill strong{ font-weight: 800; }
    .pill .muted{ color: var(--muted); }

    .btn{
      cursor:pointer;
      border:1px solid var(--line);
      background: linear-gradient(180deg, #1b2a3e 0%, #142033 100%);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 750;
      font-size: 14px;
    }
    .btn:active{ transform: translateY(1px); }
    .btnGood{
      background: linear-gradient(180deg, #1d7a41 0%, #155a31 100%);
      border-color: rgba(31,143,74,.6);
    }
    .btnWarn{
      background: linear-gradient(180deg, #a97900 0%, #7f5b00 100%);
      border-color: rgba(184,139,0,.7);
    }
    .btnBad{
      background: linear-gradient(180deg, #8f2a2a 0%, #611c1c 100%);
      border-color: rgba(176,42,42,.8);
    }
    .btnGhost{ background: transparent; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    .wrap{
      padding: 16px;
      max-width: none;
      width: 100%;
      margin: 0;
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr var(--bundle-width);
      gap: 14px;
      align-items:start;
    }

    .card{
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      min-width: 0;
    }
    h2{ margin: 0 0 10px 0; font-size: 18px; letter-spacing: .2px; }
    .sub{
      margin-top:-6px;
      margin-bottom:12px;
      font-size: 14px;
      color: var(--muted);
      line-height: 1.35;
    }

    .tableWrap{
      width: 100%;
      overflow:auto;
      border:1px solid var(--line);
      border-radius: 12px;
      background: rgba(8,12,18,.35);
    }
    table{
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      min-width: 0;
    }

    thead th{
      position: sticky;
      top: 0;
      background: rgba(17,26,36,.98);
      z-index: 2;
      text-align: center;
      font-weight: 800;
      border-bottom: 1px solid var(--line);
      padding: 12px 10px;
      white-space: nowrap;
      font-size: var(--th-font);
    }
    thead tr.labelsRow th{
      top: 44px;
      background: rgba(14,22,32,.98);
      padding: 8px 10px;
      border-bottom: 1px solid rgba(34,50,68,.7);
    }
    thead th:first-child{
      text-align:left;
      padding-left: 14px;
      z-index: 3;
    }
    thead tr.labelsRow th:first-child{ z-index: 4; }
    .lotLabelInput{
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(34,50,68,.75);
      background: #0a121a;
      color: var(--text);
      outline:none;
      font-size: 14px;
      text-align: center;
    }
    .lotLabelInput:focus{
      border-color: var(--focus);
      box-shadow: 0 0 0 3px rgba(58,160,255,.18);
    }

    tbody td, tfoot td{
      border-bottom: 1px solid rgba(34,50,68,.65);
      border-right: 1px solid rgba(34,50,68,.45);
      padding: var(--td-pad);
      text-align: center;
      vertical-align: middle;
    }
    tbody tr:last-child td{ border-bottom: none; }

    tbody td:first-child, tfoot td:first-child{
      text-align:left;
      padding-left: 14px;
      font-weight: 900;
      border-right: 1px solid rgba(34,50,68,.75);
      background: rgba(12,18,26,.65);
      position: sticky;
      left: 0;
      z-index: 1;
      white-space: nowrap;
    }

    tfoot td{
      background: rgba(12,18,26,.55);
      font-weight: 850;
      border-top: 1px solid var(--line);
    }

    .cellInput{
      width: 100%;
      min-width: 110px;
      padding: var(--cell-pad-y) var(--cell-pad-x);
      border-radius: 10px;
      border: 1px solid rgba(34,50,68,.75);
      background: var(--cell);
      color: var(--text);
      outline: none;
      font-size: var(--cell-font);
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .cellInput:focus{
      border-color: var(--focus);
      box-shadow: 0 0 0 3px rgba(58,160,255,.20);
    }
    .locked{
      border-color: rgba(31,143,74,.65) !important;
      background: rgba(31,143,74,.08) !important;
    }
    .mono{ font-variant-numeric: tabular-nums; }
    .muted{ color: var(--muted); }
    .hr{ height:1px; background: var(--line); margin: 12px 0; }
    .right{ text-align:right; }

    .statusReady{ background: rgba(31,143,74,.10) !important; border-color: rgba(31,143,74,.6) !important; color: #c8ffd9; }
    .statusNear{  background: rgba(184,139,0,.10) !important; border-color: rgba(184,139,0,.65) !important; color: #ffe6a8; }
    .statusBad{   background: rgba(176,42,42,.12) !important; border-color: rgba(176,42,42,.70) !important; color: #ffb4b4; }

    .denomTag{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .badge{
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(34,50,68,.7);
      color: var(--muted);
      background: rgba(8,12,18,.35);
      font-weight: 800;
    }
    .badge.ready{ border-color: rgba(31,143,74,.65); color:#c8ffd9; background: rgba(31,143,74,.08); }
    .badge.near{  border-color: rgba(184,139,0,.7);  color:#ffe6a8; background: rgba(184,139,0,.08); }
    .badge.bad{   border-color: rgba(176,42,42,.75); color:#ffb4b4; background: rgba(176,42,42,.08); }

    .alert{
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 10px;
      background: rgba(184,139,0,.10);
    }
    .alert.good{
      background: rgba(31,143,74,.10);
      border-color: rgba(31,143,74,.6);
    }
    .alertTitle{ font-weight: 900; margin-bottom: 6px; }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content: space-between;
      flex-wrap:wrap;
    }
    .small{ font-size: 14px; }
    .bundleItem{
      border:1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(8,12,18,.35);
      margin-top: 8px;
    }
    .note{
      font-size: 13px;
      color: var(--muted);
      line-height: 1.35;
      margin-top: 10px;
    }
    .miniGrid{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      margin-top: 8px;
      font-size: 13px;
    }

    .toolsRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }

    @media print{
      header, .noPrint{ display:none !important; }
      body{ background: #fff; color:#000; }
      .wrap{ padding:0; }
      .layout{ grid-template-columns: 1fr; }
      .card{ box-shadow:none; background:#fff; border: 1px solid #ddd; }
      .tableWrap{ border: 1px solid #ddd; background:#fff; }
      table{ font-size: 11px; }
      .cellInput{ display:none; }
      .printOnly{ display:block !important; }
    }
    .printOnly{ display:none; }

    @media (max-width: 1300px){
      :root{ --bundle-width: 1fr; }
      .layout{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<header class="noPrint">
  <div class="hdrRow">
    <div class="pill"><span class="muted">Session total</span> <strong id="sessionTotal">$0</strong></div>
    <div class="pill"><span class="muted">Bundles</span> <strong id="bundleCount">0</strong></div>
    <div class="pill"><span class="muted">Unbundled notes</span> <strong id="unbundledNotes">0</strong></div>

    <button class="btn btnGhost" id="clearLocksBtn" type="button">Clear locks</button>
    <button class="btn" id="exportJsonBtn" type="button">Export JSON</button>
    <button class="btn" id="exportCsvBtn" type="button">Export CSV</button>
    <button class="btn" id="printBtn" type="button">Print summary</button>
    <button class="btn btnBad" id="resetBtn" type="button">Reset</button>
  </div>
</header>

<div class="wrap">
  <div class="layout">
    <!-- GRID -->
    <div class="card">
      <h2>Lots grid (notes + coins)</h2>
      <div class="sub noPrint">
        Type counts into the grid. Any non-empty number ‚Äúlocks in‚Äù automatically (green outline).<br/>
        Navigation: <strong>Enter</strong> moves <strong>down</strong> (same lot column). <strong>Shift+Enter</strong> moves up. Arrow keys work like Excel.
        <strong>Ctrl+D</strong> = copy from above. <strong>Ctrl+0</strong> = clear cell.
      </div>

      <div class="tableWrap">
        <table id="gridTable" aria-label="Lots grid"></table>
      </div>

      <div class="note noPrint">
        Bundling is <strong>notes only</strong> (85 of the same denomination). Coins are tracked for totals but never bundled.
        ‚ÄúLeft (unbundled)‚Äù reflects what remains after bundles are extracted or after Final Bundles are created.
      </div>

      <div class="printOnly" id="printSummaryLeft"></div>
    </div>

    <!-- BUNDLES -->
    <div class="card">
      <h2>Bundles</h2>
      <div class="sub noPrint">
        Extract 85-note bundles as you go. When you‚Äôre done, use <strong>Final Bundles</strong> to split the remaining notes into mixed bundles of up to <strong>85</strong> each.
      </div>

      <div class="toolsRow noPrint">
        <button class="btn btnGood" id="extractMaxBtn" type="button">Extract max 85s</button>
        <button class="btn btnWarn" id="finalBundleBtn" type="button">Final Bundles (Mixed)</button>
        <button class="btn btnGhost" id="undoBtn" type="button">Undo last</button>
        <button class="btn btnGhost" id="lockBtn" type="button">Lock session</button>
      </div>

      <div id="alerts"></div>

      <div class="hr"></div>

      <h2 style="margin:0 0 8px 0;">Coin summary</h2>
      <div id="coinSummary" class="bundleItem"></div>

      <div class="hr"></div>

      <h2 style="margin:0 0 8px 0;">Bundle log</h2>
      <div id="bundleLog"></div>

      <div class="note" id="negWarn" style="display:none;">
        <strong style="color:#ffb4b4;">Warning:</strong> One or more note denominations went negative after bundles (usually caused by editing lot counts down after extracting).
        Fix by adjusting the grid back up, or undo bundles.
      </div>

      <div class="printOnly" id="printSummaryRight"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const NOTES = [100, 50, 20, 10, 5];
  const COINS = [2, 1, 0.5, 0.2, 0.1];
  const ALL = [...NOTES, ...COINS];

  const LOTS_DEFAULT = Array.from({length: 10}, (_, i) => `Lot ${i+1}`);
  const BUNDLE_SIZE = 85;
  const READY_NEAR = 70;
  const LS_KEY = "banking85_grid_v5";

  const el = {
    gridTable: document.getElementById("gridTable"),
    sessionTotal: document.getElementById("sessionTotal"),
    bundleCount: document.getElementById("bundleCount"),
    unbundledNotes: document.getElementById("unbundledNotes"),
    alerts: document.getElementById("alerts"),
    bundleLog: document.getElementById("bundleLog"),
    undoBtn: document.getElementById("undoBtn"),
    finalBundleBtn: document.getElementById("finalBundleBtn"),
    extractMaxBtn: document.getElementById("extractMaxBtn"),
    exportJsonBtn: document.getElementById("exportJsonBtn"),
    exportCsvBtn: document.getElementById("exportCsvBtn"),
    printBtn: document.getElementById("printBtn"),
    resetBtn: document.getElementById("resetBtn"),
    clearLocksBtn: document.getElementById("clearLocksBtn"),
    negWarn: document.getElementById("negWarn"),
    coinSummary: document.getElementById("coinSummary"),
    lockBtn: document.getElementById("lockBtn"),
    printSummaryLeft: document.getElementById("printSummaryLeft"),
    printSummaryRight: document.getElementById("printSummaryRight"),
  };

  const defaultState = () => ({
    version: 5,
    createdAt: new Date().toISOString(),
    lotLabels: [...LOTS_DEFAULT],
    counts: Object.fromEntries(ALL.map(v => [String(v), Array(10).fill(0)])),
    lockedCells: Object.fromEntries(ALL.map(v => [String(v), Array(10).fill(false)])),
    bundles: [],               // type:"single" or "final"
    finalBundleCreated: false, // "finalised" state
    sessionLocked: false
  });

  let state = load();

  // ---------- Grid ----------
  function buildGrid(){
    const table = el.gridTable;
    table.innerHTML = "";

    const thead = document.createElement("thead");

    const hr = document.createElement("tr");
    const th0 = document.createElement("th");
    th0.textContent = "Denomination";
    hr.appendChild(th0);

    for (let i=0;i<10;i++){
      const th = document.createElement("th");
      th.textContent = state.lotLabels[i] || LOTS_DEFAULT[i];
      th.dataset.lotHeader = String(i);
      hr.appendChild(th);
    }

    const thEntered = document.createElement("th"); thEntered.textContent = "Entered (count)"; hr.appendChild(thEntered);
    const thLeft   = document.createElement("th"); thLeft.textContent = "Left (unbundled)"; hr.appendChild(thLeft);
    const thVal    = document.createElement("th"); thVal.textContent = "Entered ($)"; hr.appendChild(thVal);

    thead.appendChild(hr);

    const lr = document.createElement("tr");
    lr.className = "labelsRow";

    const l0 = document.createElement("th");
    l0.innerHTML = `<span class="muted">Lot labels</span>`;
    lr.appendChild(l0);

    for (let i=0;i<10;i++){
      const th = document.createElement("th");
      const inp = document.createElement("input");
      inp.className = "lotLabelInput";
      inp.type = "text";
      inp.value = state.lotLabels[i] || "";
      inp.placeholder = LOTS_DEFAULT[i];
      inp.disabled = !!state.sessionLocked;
      inp.addEventListener("input", () => {
        state.lotLabels[i] = inp.value.trim() || LOTS_DEFAULT[i];
        save();
        const top = table.querySelector(`th[data-lot-header="${i}"]`);
        if (top) top.textContent = state.lotLabels[i];
      });
      th.appendChild(inp);
      lr.appendChild(th);
    }

    lr.appendChild(document.createElement("th"));
    lr.appendChild(document.createElement("th"));
    lr.appendChild(document.createElement("th"));

    thead.appendChild(lr);
    table.appendChild(thead);

    const tbody = document.createElement("tbody");

    ALL.forEach((denom, rowIndex) => {
      const tr = document.createElement("tr");
      tr.dataset.row = String(rowIndex);

      const tdLabel = document.createElement("td");
      tdLabel.innerHTML = `
        <div class="denomTag">
          <span>${denomLabel(denom)}</span>
          <span class="badge" data-badge="${cssEscape(String(denom))}"></span>
        </div>`;
      tr.appendChild(tdLabel);

      for (let col=0; col<10; col++){
        const td = document.createElement("td");
        const inp = document.createElement("input");
        inp.type = "number";
        inp.min = "0";
        inp.step = "1";
        inp.className = "cellInput mono";
        inp.inputMode = "numeric";
        inp.dataset.denom = String(denom);
        inp.dataset.row = String(rowIndex);
        inp.dataset.lot = String(col);

        const v = state.counts[String(denom)][col] || 0;
        inp.value = v ? String(v) : "";

        if (state.lockedCells[String(denom)][col] && inp.value !== "") inp.classList.add("locked");

        inp.disabled = !!state.sessionLocked;

        inp.addEventListener("blur", () => commitCell(inp));

        inp.addEventListener("keydown", (e) => {
          if (e.key === "Enter"){
            e.preventDefault();
            commitCell(inp);
            moveFocusBy(inp, e.shiftKey ? -1 : +1, 0);
            return;
          }

          if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight"){
            e.preventDefault();
            const dr = (e.key === "ArrowUp") ? -1 : (e.key === "ArrowDown") ? 1 : 0;
            const dc = (e.key === "ArrowLeft") ? -1 : (e.key === "ArrowRight") ? 1 : 0;
            commitCell(inp);
            moveFocusBy(inp, dr, dc);
            return;
          }

          if ((e.ctrlKey || e.metaKey) && (e.key === "d" || e.key === "D")){
            e.preventDefault();
            if (state.sessionLocked) return;
            copyFromAbove(inp);
            return;
          }

          if ((e.ctrlKey || e.metaKey) && e.key === "0"){
            e.preventDefault();
            if (state.sessionLocked) return;
            clearCell(inp);
            return;
          }
        });

        inp.addEventListener("input", () => {
          if (inp.value === "") inp.classList.remove("locked");
        });

        td.appendChild(inp);
        tr.appendChild(td);
      }

      const tdEntered = document.createElement("td");
      tdEntered.className = "mono right";
      tdEntered.dataset.enteredCount = String(denom);
      tr.appendChild(tdEntered);

      const tdLeft = document.createElement("td");
      tdLeft.className = "mono right";
      tdLeft.dataset.leftCount = String(denom);
      tr.appendChild(tdLeft);

      const tdVal = document.createElement("td");
      tdVal.className = "mono right";
      tdVal.dataset.enteredValue = String(denom);
      tdVal.style.fontWeight = "850";
      tr.appendChild(tdVal);

      tbody.appendChild(tr);
    });

    table.appendChild(tbody);

    const tfoot = document.createElement("tfoot");
    const fr = document.createElement("tr");

    const f0 = document.createElement("td");
    f0.textContent = "Lot total ($)";
    fr.appendChild(f0);

    for (let c=0;c<10;c++){
      const td = document.createElement("td");
      td.className = "mono right";
      td.dataset.colTotal = String(c);
      fr.appendChild(td);
    }

    fr.appendChild(document.createElement("td"));
    fr.appendChild(document.createElement("td"));

    const grand = document.createElement("td");
    grand.className = "mono right";
    grand.dataset.grandTotal = "1";
    fr.appendChild(grand);

    tfoot.appendChild(fr);
    table.appendChild(tfoot);
  }

  function commitCell(inp){
    if (state.sessionLocked) return;

    const denom = inp.dataset.denom;
    const lot = Number(inp.dataset.lot);

    const raw = inp.value;
    const n = raw === "" ? 0 : Math.max(0, Math.floor(Number(raw)));

    if (n === 0){
      inp.value = "";
      state.lockedCells[denom][lot] = false;
      inp.classList.remove("locked");
    } else {
      inp.value = String(n);
      state.lockedCells[denom][lot] = true;
      inp.classList.add("locked");
    }

    state.counts[denom][lot] = n;
    save();
    render();
  }

  function clearCell(inp){
    inp.value = "";
    commitCell(inp);
  }

  function copyFromAbove(inp){
    const row = Number(inp.dataset.row);
    const lot = Number(inp.dataset.lot);
    if (row <= 0) return;

    const aboveDenom = String(ALL[row - 1]);
    const val = state.counts[aboveDenom][lot] || 0;
    inp.value = val ? String(val) : "";
    commitCell(inp);
  }

  function moveFocusBy(currentInput, dr, dc){
    const row = Number(currentInput.dataset.row);
    const col = Number(currentInput.dataset.lot);

    let nr = row + dr;
    let nc = col + dc;

    if (nr >= ALL.length){ nr = 0; nc = Math.min(9, nc + 1); }
    if (nr < 0){ nr = ALL.length - 1; nc = Math.max(0, nc - 1); }

    if (nc < 0) nc = 0;
    if (nc > 9) nc = 9;

    const nextDenom = String(ALL[nr]);
    const sel = `.cellInput[data-denom="${cssEscape(nextDenom)}"][data-lot="${nc}"]`;
    const nextEl = document.querySelector(sel);
    if (nextEl){
      nextEl.focus();
      nextEl.select();
    }
  }

  // ---------- Math ----------
  function sumEnteredCountsByDenom(){
    const totals = Object.fromEntries(ALL.map(v => [String(v), 0]));
    for (const v of ALL){
      const k = String(v);
      totals[k] = state.counts[k].reduce((a,b)=>a+(b||0),0);
    }
    return totals;
  }

  function sumBundlesByDenom(){
    const totals = Object.fromEntries(NOTES.map(d => [String(d), 0]));
    for (const b of state.bundles){
      if (b.type === "single"){
        totals[String(b.denom)] = (totals[String(b.denom)] || 0) + b.count;
      } else if (b.type === "final"){
        for (const d of NOTES){
          totals[String(d)] = (totals[String(d)] || 0) + (b.breakdown?.[String(d)] || 0);
        }
      }
    }
    return totals;
  }

  function leftUnbundledByDenom(){
    const entered = sumEnteredCountsByDenom();
    const bundled = sumBundlesByDenom();
    const left = Object.fromEntries(ALL.map(v => [String(v), entered[String(v)] || 0]));
    for (const d of NOTES){
      left[String(d)] = (entered[String(d)] || 0) - (bundled[String(d)] || 0);
    }
    return left;
  }

  function sessionTotalValue(){
    let total = 0;
    for (const v of ALL){
      const denom = Number(v);
      const count = state.counts[String(v)].reduce((a,b)=>a+(b||0),0);
      total += count * denom;
    }
    return total;
  }

  function lotTotalValue(lotIndex){
    let total = 0;
    for (const v of ALL){
      total += (state.counts[String(v)][lotIndex] || 0) * Number(v);
    }
    return total;
  }

  function enteredValueForDenom(denomStr){
    const denom = Number(denomStr);
    const count = state.counts[denomStr].reduce((a,b)=>a+(b||0),0);
    return count * denom;
  }

  function coinTotals(){
    const entered = sumEnteredCountsByDenom();
    const counts = Object.fromEntries(COINS.map(c => [String(c), entered[String(c)] || 0]));
    const value = COINS.reduce((a,c)=> a + (counts[String(c)]||0) * c, 0);
    return { counts, value };
  }

  // ---------- Bundles ----------
  function eligibleDenoms(){
    if (state.finalBundleCreated) return [];
    const left = leftUnbundledByDenom();
    return NOTES.filter(d => (left[String(d)]||0) >= BUNDLE_SIZE).sort((a,b)=>b-a);
  }

  function extractBundle(denom){
    if (state.finalBundleCreated || state.sessionLocked) return;

    const left = leftUnbundledByDenom();
    if ((left[String(denom)] || 0) < BUNDLE_SIZE) return;

    state.bundles.unshift({
      ts: new Date().toISOString(),
      type: "single",
      denom,
      count: BUNDLE_SIZE,
      value: denom * BUNDLE_SIZE
    });
    save();
    render();
  }

  function extractMaxBundles(){
    if (state.finalBundleCreated || state.sessionLocked) return;

    let safety = 2000;
    while (safety-- > 0){
      const left = leftUnbundledByDenom();
      const elig = NOTES.filter(d => (left[String(d)]||0) >= BUNDLE_SIZE).sort((a,b)=>b-a);
      if (elig.length === 0) break;
      extractBundle(elig[0]);
    }
  }

  function createFinalBundles(){
    if (state.finalBundleCreated || state.sessionLocked) return;

    const left = leftUnbundledByDenom();

    // Remaining unbundled notes by denom (ignore negatives by clamping at 0)
    const rem = Object.fromEntries(NOTES.map(d => [String(d), Math.max(0, left[String(d)] || 0)]));

    const totalNotes = NOTES.reduce((a,d)=>a + rem[String(d)], 0);
    if (totalNotes === 0){
      alert("There are no unbundled notes left to create Final Bundles.");
      return;
    }

    // Build N bundles of up to 85 notes each, greedily taking higher denoms first.
    const bundleCount = Math.ceil(totalNotes / BUNDLE_SIZE);
    const groupId = new Date().toISOString(); // ties these finals together

    const bundlesToAdd = [];

    for (let seq = 1; seq <= bundleCount; seq++){
      let cap = BUNDLE_SIZE;
      const breakdown = {};
      let value = 0;

      for (const d of NOTES){ // NOTES already descending
        const k = String(d);
        if (cap <= 0) break;
        const take = Math.min(rem[k] || 0, cap);
        if (take > 0){
          breakdown[k] = take;
          rem[k] -= take;
          cap -= take;
          value += take * d;
        }
      }

      const notesInThis = BUNDLE_SIZE - cap;
      if (notesInThis <= 0) break;

      bundlesToAdd.push({
        ts: new Date().toISOString(),
        type: "final",
        groupId,
        seq,
        total: bundleCount,
        count: notesInThis,
        value,
        breakdown
      });
    }

    // Add in reverse so seq=1 ends up lower in the log, seq=last is most recent at top.
    for (let i = bundlesToAdd.length - 1; i >= 0; i--){
      state.bundles.unshift(bundlesToAdd[i]);
    }

    state.finalBundleCreated = true;
    state.sessionLocked = true;

    save();
    rebuildAndRender();
  }

  function undoLastBundle(){
    if (state.bundles.length === 0) return;

    const b = state.bundles.shift();

    // If we removed a final bundle, check whether any final bundles remain.
    if (b?.type === "final"){
      const stillHasFinal = state.bundles.some(x => x?.type === "final");
      if (!stillHasFinal){
        state.finalBundleCreated = false;
        state.sessionLocked = false;
      }
    }

    save();
    rebuildAndRender();
  }

  function toggleLock(){
    state.sessionLocked = !state.sessionLocked;
    save();
    rebuildAndRender();
  }

  // ---------- Render ----------
  function render(){
    const entered = sumEnteredCountsByDenom();
    const left = leftUnbundledByDenom();

    for (const v of ALL){
      const key = String(v);
      const tdEntered = document.querySelector(`[data-entered-count="${cssEscape(key)}"]`);
      const tdLeft = document.querySelector(`[data-left-count="${cssEscape(key)}"]`);
      const tdVal = document.querySelector(`[data-entered-value="${cssEscape(key)}"]`);

      if (tdEntered) tdEntered.textContent = String(entered[key] || 0);
      if (tdLeft) tdLeft.textContent = String(left[key] || 0);
      if (tdVal) tdVal.textContent = money(enteredValueForDenom(key));

      if (tdLeft){
        tdLeft.classList.remove("statusReady","statusNear","statusBad");
        if (NOTES.includes(Number(v))){
          const val = left[key] || 0;
          if (val < 0) tdLeft.classList.add("statusBad");
          else if (val >= BUNDLE_SIZE) tdLeft.classList.add("statusReady");
          else if (val >= READY_NEAR) tdLeft.classList.add("statusNear");
        }
      }

      const badge = document.querySelector(`[data-badge="${cssEscape(key)}"]`);
      if (badge){
        badge.classList.remove("ready","near","bad");
        badge.textContent = "";
        if (NOTES.includes(Number(v))){
          const val = left[key] || 0;
          if (val < 0){ badge.textContent = "NEG"; badge.classList.add("bad"); }
          else if (val >= BUNDLE_SIZE){ badge.textContent = "READY"; badge.classList.add("ready"); }
          else if (val >= READY_NEAR){ badge.textContent = "NEAR"; badge.classList.add("near"); }
          else { badge.textContent = ""; }
        }
      }
    }

    for (let c=0;c<10;c++){
      const td = document.querySelector(`[data-col-total="${c}"]`);
      if (td) td.textContent = money(lotTotalValue(c));
    }

    const gt = document.querySelector(`[data-grand-total="1"]`);
    if (gt) gt.textContent = money(sessionTotalValue());

    el.sessionTotal.textContent = money(sessionTotalValue());
    el.bundleCount.textContent = String(state.bundles.length);

    const unbundledNotes = NOTES.reduce((a,d)=>a + (left[String(d)] || 0), 0);
    el.unbundledNotes.textContent = String(unbundledNotes);

    el.finalBundleBtn.disabled = state.finalBundleCreated || state.sessionLocked;
    el.extractMaxBtn.disabled = state.finalBundleCreated || state.sessionLocked;
    el.undoBtn.disabled = (state.bundles.length === 0);
    el.lockBtn.textContent = state.sessionLocked ? "Unlock session" : "Lock session";
    el.lockBtn.classList.toggle("btnWarn", state.sessionLocked);

    const hasNeg = NOTES.some(d => (left[String(d)] || 0) < 0);
    el.negWarn.style.display = hasNeg ? "block" : "none";

    el.alerts.innerHTML = "";

    if (state.sessionLocked){
      const div = document.createElement("div");
      div.className = "alert";
      div.innerHTML = `
        <div class="alertTitle">Session locked üîí</div>
        <div class="small muted">Grid is read-only. Unlock to edit counts or extract more bundles.</div>`;
      el.alerts.appendChild(div);
    }

    if (state.finalBundleCreated){
      const finalCount = state.bundles.filter(b => b.type === "final").length;
      const div = document.createElement("div");
      div.className = "alert good";
      div.innerHTML = `
        <div class="alertTitle">Final Bundles created ‚úÖ</div>
        <div class="small muted">${finalCount} final bundle(s) made (up to 85 notes each). Undo final bundles to continue bundling.</div>`;
      el.alerts.appendChild(div);
    }

    const elig = eligibleDenoms();
    if (!state.finalBundleCreated){
      if (elig.length === 0){
        const div = document.createElement("div");
        div.className = "alert";
        div.innerHTML = `
          <div class="alertTitle">No 85 bundles ready</div>
          <div class="small muted">Keep entering counts, click <strong>Extract max 85s</strong> when ready, or use <strong>Final Bundles</strong> when finished.</div>`;
        el.alerts.appendChild(div);
      } else {
        for (const d of elig){
          const available = left[String(d)] || 0;
          const div = document.createElement("div");
          div.className = "alert good";
          div.innerHTML = `
            <div class="alertTitle">READY: ${BUNDLE_SIZE} √ó $${d}</div>
            <div class="row small mono">
              <div><span class="muted">Left (unbundled):</span> <strong>${available}</strong></div>
              <button class="btn btnGood" type="button">Extract</button>
            </div>`;
          div.querySelector("button").disabled = state.sessionLocked;
          div.querySelector("button").addEventListener("click", () => extractBundle(d));
          el.alerts.appendChild(div);
        }
      }
    }

    const coins = coinTotals();
    el.coinSummary.innerHTML = `
      <div class="row">
        <div><strong>Total coins</strong></div>
        <div class="mono"><strong>${money(coins.value)}</strong></div>
      </div>
      <div class="miniGrid">
        ${COINS.map(c => `
          <div><span class="muted">${coinLabel(c)}:</span></div>
          <div class="right mono"><strong>${coins.counts[String(c)] || 0}</strong></div>
        `).join("")}
      </div>
    `;

    el.bundleLog.innerHTML = "";
    if (state.bundles.length === 0){
      const div = document.createElement("div");
      div.className = "bundleItem small muted";
      div.textContent = "No bundles created yet.";
      el.bundleLog.appendChild(div);
    } else {
      state.bundles.slice(0, 160).forEach((b, idx) => {
        const div = document.createElement("div");
        div.className = "bundleItem";

        if (b.type === "single"){
          div.innerHTML = `
            <div class="row">
              <div><strong>Bundle ${state.bundles.length - idx}</strong> <span class="muted">(85)</span></div>
              <div class="mono"><strong>${b.count}</strong> √ó $${b.denom} = <strong>${money(b.value)}</strong></div>
            </div>
            <div class="small muted" style="margin-top:6px;">${fmt(b.ts)}</div>
          `;
        } else {
          const lines = NOTES
            .filter(d => (b.breakdown?.[String(d)] || 0) > 0)
            .map(d => `<div><span class="muted">$${d}:</span></div><div class="right mono"><strong>${b.breakdown[String(d)]}</strong></div>`)
            .join("");

          const label = (Number.isFinite(b.seq) && Number.isFinite(b.total))
            ? `Final Bundle (${b.seq}/${b.total})`
            : `Final Bundle`;

          div.innerHTML = `
            <div class="row">
              <div><strong>${label}</strong> <span class="muted">(mixed)</span></div>
              <div class="mono"><strong>${b.count}</strong> notes = <strong>${money(b.value)}</strong></div>
            </div>
            <div class="miniGrid">
              ${lines || `<div class="muted">No notes?</div><div></div>`}
            </div>
            <div class="small muted" style="margin-top:8px;">${fmt(b.ts)}</div>
          `;
        }

        el.bundleLog.appendChild(div);
      });
    }

    // (Print/export summary still works; omitted here to keep this version focused)
  }

  // ---------- Exports / print (same as before) ----------
  function exportJson(){
    const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
    downloadBlob(blob, "banking-grid-session.json");
  }

  function exportCsv(){
    const entered = sumEnteredCountsByDenom();

    const header = ["Denomination", ...state.lotLabels.map(x => x || ""), "EnteredCount", "EnteredValue"].join(",");
    const rows = ALL.map(v => {
      const k = String(v);
      const denomName = denomLabel(Number(v));
      const lotCounts = state.counts[k].map(n => String(n || 0));
      const enteredCount = String(entered[k] || 0);
      const enteredValue = String(enteredValueForDenom(k));
      return [csvCell(denomName), ...lotCounts, enteredCount, enteredValue].join(",");
    });
    const lotsCsv = [header, ...rows].join("\n");

    const bHeader = ["Timestamp","Type","NotesCount","Denomination","Value","FinalSeq","FinalTotal","Breakdown"].join(",");
    const bRows = state.bundles.map(b => {
      const denom = b.type === "single" ? String(b.denom) : "";
      const breakdown = b.type === "final"
        ? NOTES.filter(d => (b.breakdown?.[String(d)]||0) > 0).map(d => `${b.breakdown[String(d)]}x${d}`).join(" | ")
        : "";
      return [
        csvCell(b.ts),
        csvCell(b.type),
        String(b.count || 0),
        csvCell(denom),
        String(b.value || 0),
        csvCell(b.type === "final" ? (b.seq ?? "") : ""),
        csvCell(b.type === "final" ? (b.total ?? "") : ""),
        csvCell(breakdown)
      ].join(",");
    });
    const bundlesCsv = [bHeader, ...bRows].join("\n");

    downloadBlob(new Blob([lotsCsv], {type:"text/csv"}), "lots.csv");
    downloadBlob(new Blob([bundlesCsv], {type:"text/csv"}), "bundles.csv");
  }

  function printSummary(){
    window.print();
  }

  // ---------- Buttons ----------
  el.undoBtn.addEventListener("click", undoLastBundle);
  el.finalBundleBtn.addEventListener("click", () => {
    if (!confirm("Create FINAL BUNDLES from ALL remaining unbundled notes (mixed). This may create multiple bundles (up to 85 notes each) and will lock the session.")) return;
    createFinalBundles();
  });
  el.extractMaxBtn.addEventListener("click", extractMaxBundles);
  el.lockBtn.addEventListener("click", toggleLock);

  el.exportJsonBtn.addEventListener("click", exportJson);
  el.exportCsvBtn.addEventListener("click", exportCsv);
  el.printBtn.addEventListener("click", printSummary);

  el.resetBtn.addEventListener("click", () => {
    if (!confirm("Reset everything (grid + bundles + labels)?")) return;
    state = defaultState();
    save();
    rebuildAndRender();
    focusFirst();
  });

  el.clearLocksBtn.addEventListener("click", () => {
    for (const v of ALL) state.lockedCells[String(v)] = Array(10).fill(false);
    save();
    document.querySelectorAll(".cellInput").forEach(inp => inp.classList.remove("locked"));
  });

  // ---------- Storage ----------
  function load(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return defaultState();
      const parsed = JSON.parse(raw);
      const st = defaultState();

      if (Array.isArray(parsed?.lotLabels)){
        st.lotLabels = parsed.lotLabels.slice(0,10).map((x,i)=> (typeof x === "string" && x.trim()) ? x.trim() : LOTS_DEFAULT[i]);
        while (st.lotLabels.length < 10) st.lotLabels.push(LOTS_DEFAULT[st.lotLabels.length]);
      }

      if (parsed?.counts){
        for (const v of ALL){
          const key = String(v);
          const arr = parsed.counts[key];
          if (Array.isArray(arr)){
            st.counts[key] = arr.slice(0,10).map(x => Number.isFinite(x) && x >= 0 ? Math.floor(x) : 0);
            while (st.counts[key].length < 10) st.counts[key].push(0);
          }
        }
      }

      if (parsed?.lockedCells){
        for (const v of ALL){
          const key = String(v);
          const arr = parsed.lockedCells[key];
          if (Array.isArray(arr)){
            st.lockedCells[key] = arr.slice(0,10).map(x => !!x);
            while (st.lockedCells[key].length < 10) st.lockedCells[key].push(false);
          }
        }
      }

      if (Array.isArray(parsed?.bundles)){
        st.bundles = parsed.bundles.map(b => ({
          ts: typeof b.ts === "string" ? b.ts : new Date().toISOString(),
          type: b.type || "single",
          denom: b.denom,
          count: b.count,
          value: b.value,
          breakdown: b.breakdown,
          groupId: b.groupId,
          seq: b.seq,
          total: b.total
        })).filter(b => b && Number.isFinite(b.count));
      }

      st.finalBundleCreated = !!parsed.finalBundleCreated;
      st.sessionLocked = !!parsed.sessionLocked;
      st.createdAt = typeof parsed.createdAt === "string" ? parsed.createdAt : st.createdAt;

      return st;
    } catch {
      return defaultState();
    }
  }

  function save(){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function rebuildAndRender(){
    buildGrid();
    render();
  }

  // ---------- Helpers ----------
  function denomLabel(v){
    if (v >= 5) return `$${v}`;
    if (v === 2) return "$2";
    if (v === 1) return "$1";
    if (v === 0.5) return "50c";
    if (v === 0.2) return "20c";
    if (v === 0.1) return "10c";
    return String(v);
  }

  function coinLabel(v){
    if (v === 2) return "$2";
    if (v === 1) return "$1";
    if (v === 0.5) return "50c";
    if (v === 0.2) return "20c";
    if (v === 0.1) return "10c";
    return String(v);
  }

  function money(n){
    const hasCents = Math.abs(n - Math.round(n)) > 1e-9;
    return "$" + (n || 0).toLocaleString(undefined, {
      minimumFractionDigits: hasCents ? 2 : 0,
      maximumFractionDigits: hasCents ? 2 : 0
    });
  }

  function fmt(iso){
    try{
      const d = new Date(iso);
      return d.toLocaleString(undefined, {year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit"});
    } catch { return iso; }
  }

  function cssEscape(s){
    return String(s).replace(/"/g, '\\"');
  }

  function focusFirst(){
    const first = document.querySelector('.cellInput');
    if (first) { first.focus(); first.select(); }
  }

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function csvCell(s){
    const str = String(s ?? "");
    if (/[",\n]/.test(str)) return `"${str.replace(/"/g,'""')}"`;
    return str;
  }

  // ---------- Start ----------
  rebuildAndRender();
  focusFirst();
})();
</script>
</body>
</html>
